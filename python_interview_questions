1. Explain Python’s Global Interpreter Lock (GIL). How does it affect multithreading?
Answer: The Global Interpreter Lock (GIL) is a mutex that allows only one thread to execute Python bytecode at a time in a single process. It limits the performance of multi-threaded Python programs because CPU-bound tasks cannot fully utilize multiple CPU cores. However, I/O-bound tasks can benefit from multithreading because the GIL is released during I/O operations like reading/writing files, network requests, etc.
Workaround: To fully utilize multiple cores, you can use multiprocessing instead of threading, as each process has its own memory space and GIL.

2. What are Python decorators? Can you provide an example where they might be useful?
Answer: Decorators in Python are functions that modify the behavior of other functions or methods. They are commonly used for logging, access control, memoization, and more.
Example:
python

def my_decorator(func):
    def wrapper():
        print("Before function call")
        func()
        print("After function call")
    return wrapper
@my_decoratordef say_hello():
    print("Hello!")

say_hello()
In this case, my_decorator wraps the say_hello function to print messages before and after the original function is called.

3. What is the difference between deep copy and shallow copy in Python?
Answer:
oA shallow copy creates a new object, but inserts references into the new object instead of copying the objects themselves. Therefore, changes to mutable elements in the original object will affect the shallow copy.
oA deep copy creates a completely independent object and recursively copies all nested objects, meaning that changes to the original object won't affect the deep copy.
Example:
python

import copy

original = [[1, 2, 3], [4, 5, 6]]
shallow = copy.copy(original)
deep = copy.deepcopy(original)

original[0][0] = 10print(shallow)  # Changes affect shallow copyprint(deep)     # Deep copy remains unaffected

4. What is the yield keyword in Python, and how does it differ from return?
Answer: The yield keyword is used in generator functions to produce a series of values lazily, instead of returning all values at once. When the function is called, it returns an iterator object that can be iterated over.
oreturn exits the function and sends a value back to the caller.
oyield pauses the function’s execution and sends a value to the caller, but the function’s state is saved. It can be resumed later from where it left off.
Example:
python

def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

counter = count_up_to(5)for num in counter:
    print(num)

5. What are metaclasses in Python? How do they work?
Answer: A metaclass is a class of a class. It defines how a class behaves. In Python, classes themselves are instances of metaclasses. A metaclass allows you to modify class creation, customize inheritance, and implement other behaviors that occur when a class is defined.
Example:
python

class Meta(type):
    def __new__(cls, name, bases, dct):
        dct['id'] = 42  # Add a new attribute to the class
        return super().__new__(cls, name, bases, dct)
class MyClass(metaclass=Meta):
    pass
print(MyClass.id)  # 42

6. Explain the difference between @staticmethod, @classmethod, and regular methods in Python.
Answer:
o@staticmethod: A method that does not operate on an instance of the class or modify class-level attributes. It behaves like a regular function but belongs to the class's namespace.
o@classmethod: A method that operates on the class itself, not on the instance. It takes the class as the first argument (cls) and is often used to define factory methods.
oRegular method: An instance method that operates on an instance of the class. It takes the instance as the first argument (self).
Example:
python

class MyClass:    @staticmethod
    def static_method():
        print("This is a static method.")
    @classmethod
    def class_method(cls):
        print(f"This is a class method of {cls}.")

    def instance_method(self):
        print("This is an instance method.")

obj = MyClass()
obj.instance_method()  # Calls instance method
obj.class_method()     # Calls class method
obj.static_method()    # Calls static method

7. What are Python’s built-in data structures, and when should you use each?
Answer:
oList: Ordered, mutable, and allows duplicates. Use it for collections of items where order matters.
oTuple: Ordered, immutable, and allows duplicates. Use it when data integrity is important, and you don’t want the data to be modified.
oSet: Unordered, mutable, and no duplicates. Use it when you need to store unique items and don’t care about order.
oDictionary: Unordered, mutable, and stores key-value pairs. Use it when you need fast lookups by keys.

8. What is the __slots__ attribute in Python? How does it improve memory usage?
Answer: The __slots__ attribute is used to limit the set of attributes a class can have. By defining __slots__, Python no longer needs to store attributes in a dictionary, which reduces memory usage.
Example:
python

class MyClass:
    __slots__ = ['name', 'age']

obj = MyClass()
obj.name = 'Alice'
obj.age = 30
Without __slots__, Python stores each instance's attributes in a dictionary. With __slots__, only the specified attributes are stored, saving memory.

9. How does Python handle memory management?
Answer: Python uses automatic memory management involving a private heap space, garbage collection (GC), and reference counting.
oReference Counting: Every object has a reference count that is incremented when a reference to the object is created and decremented when it’s deleted. When the count reaches zero, the object is deallocated.
oGarbage Collection: Python also has a cyclic garbage collector that detects and cleans up reference cycles (when objects reference each other in a cycle and can’t be freed by reference counting alone).

10. How do you optimize Python code for performance?
Answer:
oProfile your code using tools like cProfile to identify bottlenecks.
oUse list comprehensions instead of loops for better performance in many cases.
oAvoid using global variables inside loops, as accessing them is slower.
oUse built-in functions like sum(), min(), etc., instead of custom implementations.
oFor CPU-bound tasks, use multiprocessing instead of threading due to the GIL.
oUse NumPy for numerical computations to leverage highly optimized C-based functions.

These advanced Python questions are designed to test both your technical knowledge and problem-solving abilities. Practice answering them thoroughly to prepare for high-level Python interviews.
2/2
4o mini
You said:
python lattest interview questions advance level


Here’s a curated list of advanced-level Python interview questions designed to reflect the latest trends and topics relevant in Python development for 2025:

1. What are structural pattern matching and the match statement in Python?
Introduced in Python 3.10, the match statement is similar to a switch statement in other languages, enabling concise conditional code based on the structure of data.
Example:

python





def process_command(command):
    match command:
        case {"action": "create", "type": "file"}:
            print("Creating a file")
        case {"action": "delete", "type": "file"}:
            print("Deleting a file")
        case _:
            print("Unknown command")

process_command({"action": "create", "type": "file"})



2. What is the difference between asynchronous generators and synchronous generators?
Synchronous Generators: Use yield and work with synchronous code.
Asynchronous Generators: Use async def and yield along with await. They are useful in asynchronous workflows to lazily produce values.
Example:

python





async def async_gen():
    for i in range(3):
        await asyncio.sleep(1)
        yield i
async def main():
    async for value in async_gen():
        print(value)

asyncio.run(main())



3. How do you handle circular imports in Python?
Circular imports occur when two modules try to import each other, leading to dependency issues.
Solutions:
oRefactor code to avoid cyclic dependencies.
oUse import statements inside functions or methods instead of at the top of the module.
oUse lazy imports in Python 3.7+ with importlib.

4. Explain type hinting in Python and its advantages.
Type hints, introduced in PEP 484, allow developers to specify the types of variables, function arguments, and return values.
Example:

python





def add_numbers(a: int, b: int) -> int:
    return a + b


Advantages:
oImproves code readability.
oFacilitates static analysis using tools like mypy and Pyright.
oHelps IDEs provide better autocompletion and error detection.

5. What are data classes, and how do they differ from regular classes?
Data classes (introduced in Python 3.7) simplify the creation of classes used for storing data by automatically generating boilerplate code like __init__, __repr__, and __eq__.
Example:

python





from dataclasses import dataclass
@dataclassclass Point:
    x: int
    y: int

point = Point(10, 20)print(point)  # Output: Point(x=10, y=20)



6. What is the purpose of the functools.cache decorator?
Introduced in Python 3.9, functools.cache is used to cache results of expensive function calls, improving performance for functions with the same inputs.
Example:

python





from functools import cache
@cachedef fib(n):
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)
print(fib(100))  # Fast due to caching



7. How do context managers work, and how can you create a custom one?
Context managers manage resources (like files or database connections) with the with statement.
Custom Context Manager:

python





class MyContext:
    def __enter__(self):
        print("Entering context")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting context")
with MyContext():
    print("Inside context")



8. What are the differences between asyncio, threading, and multiprocessing?
Asyncio:
oSingle-threaded.
oHandles I/O-bound tasks efficiently using the async/await syntax.
Threading:
oUses threads for concurrency.
oLimited by the Global Interpreter Lock (GIL).
Multiprocessing:
oSpawns separate processes.
oAvoids the GIL and is suitable for CPU-bound tasks.

9. Explain how Python’s garbage collection works.
Python uses reference counting and a cyclic garbage collector:
oReference Counting: An object is deallocated when its reference count drops to zero.
oCyclic Garbage Collection: Identifies and collects objects involved in reference cycles.
Example:
python

import gc
gc.collect()  # Trigger garbage collection manually

10. How can you improve the performance of a Python application?
Use built-in functions: Leverage Python’s optimized built-in libraries.
List comprehensions: Use comprehensions instead of loops.
Multiprocessing: For CPU-bound tasks.
NumPy: For numerical computations.
Caching: Use functools.cache or lru_cache.
Cython or PyPy: Compile Python code for performance boosts.

11. What are weak references in Python?
Weak references (from the weakref module) allow objects to be referenced without preventing their garbage collection.
Example:

python





import weakref
class MyClass:
    pass

obj = MyClass()
weak_obj = weakref.ref(obj)print(weak_obj())  # <__main__.MyClass object>del objprint(weak_obj())  # None



12. Explain the purpose of the asyncio.run method.
Answer: asyncio.run is used to execute the top-level coroutine in an asyncio program. It sets up the event loop, runs the coroutine, and shuts down the loop afterward.
Example:
python

import asyncio
async def hello():
    print("Hello, world!")

asyncio.run(hello())

13. What are Python wheels, and how do they differ from source distributions?
Wheel: A built package format for Python, introduced in PEP 427.
oFaster installation (no need to compile code).
oPlatform-specific.
Source Distribution: Requires building the package from source during installation.

14. What is the difference between is and == in Python?
is checks for object identity (whether two variables point to the same memory location).
== checks for value equality (whether two objects have the same value).

15. What are Python’s abstract base classes (ABCs)?
ABCs (from abc module) define a blueprint for classes by specifying abstract methods that must be implemented by subclasses.
Example:
python

from abc import ABC, abstractmethod
class Shape(ABC):    @abstractmethod
    def area(self):
        pass
class Circle(Shape):
    def area(self):
        return "Circle area"
print(Circle().area())

16. How do Python coroutines work, and how are they different from regular generators?
Coroutines:
oCreated with async def and can use await.
oUsed for asynchronous workflows.
Generators:
oCreated with def and yield.
oUsed for lazily producing values.

17. Explain the purpose of Python’s dataclasses.field function.
Used to customize field behavior in a dataclass.
Example:

python





from dataclasses import dataclass, field
@dataclassclass Person:
    name: str
    age: int = field(default=30, metadata={"unit": "years"})
print(Person("John"))  # Person(name='John', age=30)



These questions cover advanced Python concepts and reflect the current practices in Python development.
2/2
4o
